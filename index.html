<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Dynamic Polymorphism Without Virtual Methods</title>
    <meta name="author" content="Roman Siromakha">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <link rel="stylesheet" href="plugins/reveal-line-numbers/line-numbers.css">
    <link rel="stylesheet" href="custom.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="highlight/styles/dracula.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
            <h1>Dynamic Polymorphism Without Virtual Methods</h1>
        </section>

        <section data-markdown>
          <script type="text/template">
### The Problem

Handle any of given HTTP-requests
```http
GET /users/23474322/contacts/31 HTTP/1.1
Host: mail.yandex.ru

PUT /users/23474322/lists HTTP/1.1
Host: mail.yandex.ru

DELETE /users/23474322/tags/3 HTTP/1.1
Host: mail.yandex.ru
```

</script></section><section data-markdown><script type="text/template">

### The problem conditions

Assume we have already parsed request
```c++
struct Request {
  std::string method;
  std::vector<std::string> uri;
};

Request request;
request.method = "GET";
request.uri = {"users", "23474322", "contacts", "31"};
```

</script></section><section data-markdown><script type="text/template">

### The problem conditions

And we can define state machine which handler to call with given input

</script></section><section data-markdown><script type="text/template">

### Handlers

```c++
void get_contact(UsersId user_id, ContactId contact, Response& response);
void create_list(UsersId user_id, Response& response);
void delete_tag(UsersId user_id, TagId tag_id, Response& response);
```

</script></section><section data-markdown><script type="text/template">

### Simple problem

```c++
struct Fizz;
struct Buzz;

void foo(Fizz);
void bar(Buzz);

// If type is foo should construct Fizz from given value and call foo.
// If type is bar should construct Buzz from given value and call bar.
// Otherwise should throw an exception.
void route(std::string type, std::string value);
```

</script></section><section data-markdown><script type="text/template">

### If-else solution

```c++
void route(std::string type, std::string value) {
  if (type == "foo") {
    foo(Fizz {std::move(value)});
  } else if (type == "bar") {
    bar(Buzz {std::move(value)});
  } else {
    using std::string_literals;
    throw std::invalid_argument("Unknown type: "s + type);
  }
}
```

</script></section><section data-markdown><script type="text/template">

### What if there are more?
```c++
void foo(Fizz);
void bar(Buzz);
void far(Fuzz);
void boo(Bizz);
void bor(Zzzz);
void fao(Ffff);
void bao(Bbbb);
void bbb(Bfzz);
void fff(Ffzz);
void wtf(Ziff);

void route(std::string type, std::string value);
```

</script></section><section data-markdown><script type="text/template">

### Ok, no problem

```c++
void route(std::string type, std::string value) {
  if (type == "foo") foo(Fizz {std::move(value)});
  else if (type == "bar") bar(Buzz {std::move(value)});
  else if (type == "far") far(Fuzz {std::move(value)});
  else if (type == "boo") boo(Bizz {std::move(value)});
  else if (type == "bor") boo(Zzzz {std::move(value)});
  else if (type == "fao") fao(Ffff {std::move(value)});
  else if (type == "bao") bao(Bbbb {std::move(value)});
  else if (type == "bbb") bbb(Bfzz {std::move(value)});
  else if (type == "fff") fff(Ffzz {std::move(value)});
  else if (type == "wtf") wtf(Ziff {std::move(value)});
  else throw std::invalid_argument("Go home");
}
```

</script></section><section data-markdown><script type="text/template">

### Looks fine

</script></section><section data-markdown><script type="text/template">

### No, wait...

Was there any typo?

</script></section><section><pre><code data-trim>
void route(std::string type, std::string value) {
  if (type == "foo") foo(Fizz {std::move(value)});
  else if (type == "bar") bar(Buzz {std::move(value)});
  else if (type == "far") far(Fuzz {std::move(value)});
  else if (type == "boo") boo(Bizz {std::move(value)});
  else if (type == "bor") <mark>boo(Bizz</mark> {std::move(value)});
  else if (type == "fao") fao(Ffff {std::move(value)});
  else if (type == "bao") bao(Bbbb {std::move(value)});
  else if (type == "bbb") bbb(Bfzz {std::move(value)});
  else if (type == "fff") fff(Ffzz {std::move(value)});
  else if (type == "wtf") wtf(Ziff {std::move(value)});
  else throw std::invalid_argument("Go home");
}
</code></pre></section><section data-markdown><script type="text/template">

### How about little optimization?

```c++
enum Type;
Type make_type(std::string);
void route(std::string type, std::string value) {
  switch (make_type(type)) {
    case Type::foo: foo(Fizz {std::move(value)});
    case Type::bar: bar(Buzz {std::move(value)});
    case Type::far: far(Fuzz {std::move(value)});
    case Type::boo: boo(Bizz {std::move(value)});
    case Type::bor: bor(Zzzz {std::move(value)});
    case Type::fao: fao(Ffff {std::move(value)});
    case Type::bao: bao(Bbbb {std::move(value)});
    case Type::bbb: bbb(Bfzz {std::move(value)});
    case Type::fff: fff(Ffzz {std::move(value)});
    case Type::wtf: wtf(Ziff {std::move(value)});
  }
}
```

</script></section><section data-markdown><script type="text/template">

### How about virtual?

```c++
struct Base {
  virtual void call(std::string value) = 0;
};
using Map = std::map<Type, std::unique_ptr<Base>>;
void route(Map alternatives, std::string type, std::string value) {
  alternatives.at(make_type(type))->call(std::move(value));
}
struct Foo : Base {
  void call(std::string value) override {
    const Fizz typed_value {value};
    // ...
  }
};
```

</script></section><section data-markdown><script type="text/template">

### How about different number of arguments?

```c++
void foo(Fizz);
void bar(Fizz, Buzz);
```

</script></section><section data-markdown><script type="text/template">

### Interface class

```c++
struct Interface {
  using It = std::vector<std::string>::const_iterator;

  virtual int route0(It it, It end) const = 0;
  virtual int route1(It it, It end, const std::string& arg0) const = 0;
  virtual int route2(It it, It end, const std::string& arg0,
                      const std::string& arg1) const = 0;
  // ...
};
```

</script></section><section data-markdown><script type="text/template">

### Router class

```c++
struct Router : Interface {
  std::map<std::string, std::shared_ptr<Interface>> alternatives;
  void route2(It it, It end, const std::string& arg0,
                  const std::string& arg1) const override {
    if (it == end) {
      throw std::invalid_argument("path is not found");
    }
    const auto next = alternatives.find(*it);
    if (next != alternatives.end()) {
      return next->second->route2(++it, end, arg0, arg1);
    } else {
      const auto& arg2 = *it;
      return route3(++it, end, arg0, arg1, arg2);
    }
  }
  // ...
};
```

</script></section><section data-markdown><script type="text/template">

### Endpoint class

```c++
struct Foo : Interface {
  void route1(It, It, const std::string& arg0) const override {
    return foo(Fizz {arg0});
  }
};
struct Bar : Interface {
  void route0(It, It) const {
    throw std::logic_error("invalid call");
  }
  void route1(It, It, const std::string&) const {
    throw std::logic_error("invalid call");
  }
  void route2(It, It, const std::string& arg0,
                  const std::string& arg1) const override {
    return bar(Fizz {arg0}, Buzz {arg1});
  }
};
```

</script></section><section data-markdown><script type="text/template">

### Or we can use tuples as for arguments

```c++
struct Base {
  using It = std::vector<std::string>::const_iterator;
  using StringCref = std::reference_wrapper<const std::string>;

  virtual int route0(It it, It end,
                        const std::tuple<>& arguments) const = 0;
  virtual int route1(It it, It end,
                        const std::tuple<StringCref>& arguments) const = 0;
  virtual int route2(It it, It end,
                        const std::tuple<StringCref, StringCref>& arguments) = 0;
  // ...
};
```

</script></section><section data-markdown><script type="text/template">

### Or even more general approach

```c++
struct Base {
  using Arguments = std::variant<
    std::tuple<>,
    std::tuple<StringCref>,
    std::tuple<StringCref, StringCref>,
    // ...
  >;
  virtual void route(It it, It end, const Arguments& arguments) = 0;
};
```

</script></section><section data-markdown><script type="text/template">

### Then endpoint class will be visitor

```c++
template <class Visitor>
struct Endpoint : Interface {
  void route(It, It, const std::string&, const Arguments& arguments) const override {
    return std::visit(
      [] (const auto& arguments) { return hana::unpack(arguments, Visitor {}); },
      arguments
    );
  }
};
struct BarVisitor {
  template <class ... Ts>
  void operator ()(Ts&& ...) const {
    throw std::logic_error("invalid call");
  }
  void operator ()(Base::StringCref arg0, Base::StringCref arg1) const {
    return bar(Fizz {arg0.get()}, Buzz {arg1.get()});
  }
};
using Bar = Endpoint<BarVisitor>;
```

</script></section><section data-markdown><script type="text/template">

### Why do we need virtual at first place?

If we can't do this...
```c++
class Inteface {
  template <class ... Ts>
  virtual void route(It it, It end, Ts&& ...) = 0;
};
```
...but can do with std::variant and std::visit.

</script></section><section data-markdown><script type="text/template">

### Let's do it different way

Back to the original problem...

</script></section><section data-markdown><script type="text/template">

### Back to the original problem

```c++
void get_contact(UsersId user_id, ContactId contact, Stream& stream);
void create_list(UsersId user_id, Stream& stream);
void delete_tag(UsersId user_id, TagId tag_id, Stream& stream);

const auto api =
  "users"_l / user_id / (
    "contacts"_l / contact_id / "GET"_m(get_contact)
    | "lists"_l / "PUT"_m(create_list)
    | "tags"_l / tag_id / "DELETE"_m(delete_tag)
  );

template <class Api>
void route(const Api& api, const std::vector<std::string>& path,
              const std::string& method);
```

<span class="fragment current-only" data-code-focus="5-10">Define API by DSL using overloaded operators</span>
<span class="fragment current-only" data-code-focus="12-14">Call API method using given input</span>

</script></section><section data-markdown><script type="text/template">

### Location

```c++
template <class CharT, CharT ... c>
constexpr auto operator "" _l() {
  return location<hana::string<c ...>>;
}

template <class CharT, CharT ... c>
constexpr auto operator "" _location() { /*...*/ }
```

</script></section><section data-markdown><script type="text/template">

### Location

```c++
struct LocationTag {};

template <class T>
struct Location {
  using address_type = T;
  using hana_tag = LocationTag;
};

template <class T>
constexpr auto location = Location<std::decay_t<T>> {};
```

</script></section><section data-markdown><script type="text/template">

### Method

```c++
struct MethodTag {};

template <class T>
struct Method {
  using name_type = T;

  template <class T>
  constexpr auto operator ()(T&& v) const {
    return tree(hana::make_tuple(hana::make_pair(*this, handler(std::forward<T>(v)))));
  }
};
```

</script></section><section data-markdown><script type="text/template">

### Handler

```c++
struct HandlerTag {};

template <class T>
struct Handler {
  using hana_tag = HandlerTag;
  T impl;
};

template <class T>
constexpr auto handler(T&& value) {
  return Handler<std::decay_t<T>> {std::forward<T>(value)};
};
```

</script></section><section data-markdown><script type="text/template">

### Tree

```c++
struct TreeTag {};

template <class T>
struct Tree {
  using hana_tag = TreeTag;
  T value;
};

template <class T>
constexpr auto tree(T&& value) {
  return Tree<std::decay_t<T>> {std::forward<T>(value)};
}
```

</script></section><section data-markdown><script type="text/template">

### Parameter

```c++
struct ParameterTag {};

template <class T>
struct Parameter {
  using value_type = T;
  using hana_tag = ParameterTag;
};

template <class T>
constexpr auto parameter = Parameter<std::decay_t<T>> {};

constexpr auto user_id = parameter<UserId>;
```

</script></section><section data-markdown><script type="text/template">

### Sequence operator

```c++
template <class Lhs, class Rhs>
constexpr auto operator /(const Tree<Location<Lhs>>& lhs, const Location<Rhs>& rhs) {
  return lhs.value / rhs;
}

template <class Lhs, class Rhs>
constexpr auto operator /(const Location<Lhs>& lhs, const Location<Rhs>& rhs) {
  return tree(hana::make_tuple(hana::make_pair(lhs, rhs)));
}

template <class Lhs1, class Lhs2, class Rhs>
constexpr auto operator /(const hana::pair<Lhs1, Lhs2>& lhs, const Location<Rhs>& rhs) {
  return tree(hana::make_tuple(hana::make_pair(hana::first(lhs),
                              (tree(hana::second(lhs)) / rhs).value)));
}
```

<span class="fragment current-only" data-code-focus="1-4">Append location</span>
<span class="fragment current-only" data-code-focus="6-9">Concat locations</span>
<span class="fragment current-only" data-code-focus="11-17">Rotate tree</span>

</script></section><section data-markdown><script type="text/template">

### Alternatives operator

```c++
template <class ... Lhs, class ... Rhs>
constexpr auto operator |(const Tree<hana::tuple<Lhs ...>>& lhs,
                          const Tree<hana::tuple<Rhs ...>>& rhs) {
  return tree(hana::concat(lhs.value, rhs.value));
}
```
</script></section><section data-markdown><script type="text/template">

### API object type

```c++
using Users = decltype("users"_s);
using Contacts = decltype("contacts"_s);
using Tags = decltype("contacts"_s);
using API = Tree<hana::tuple<
  hana::pair<Location<decltype("users"_s)>, hana::tuple<
    hana::pair<Location<decltype("contacts"_s)>, hana::tuple<
      hana::pair<Method<decltype("contacts"_s)>, Handler<decltype(get_all_contacts)>>
      // ...
    >>,
    hana::pair<Location<decltype("tags"_s)>, hana::tuple<
      // ...
    >>
  >>
>>;
```

</script></section><section data-markdown><script type="text/template">

### How to call handler?

</script></section><section data-markdown><script type="text/template">

### We can find element in tuple!

</script></section><section data-markdown><script type="text/template">

```c++
hana::find_if(nodes, [] (const auto& v) { ... });
```

</script></section><section data-markdown><script type="text/template">

### Is there something more efficient?

</script></section><section data-markdown><script type="text/template">

### Binary search!

</script></section><section data-markdown><script type="text/template">

### Binary search for tuple

```c++
template <class Result, class ... T, class Value, class Less, class Equal, class F>
constexpr std::optional<Result> binary_search(const hana::tuple<T ...>& range,
    const Value& value, Less&& less, Equal&& equal, F&& function) {
  return detail::binary_search_impl<std::size_t(0), sizeof ... (T), Result>(
    range,
    value,
    std::forward<Less>(less),
    std::forward<Equal>(equal),
    std::forward<Function>(function)
  );
}
```
<span class="fragment current-only" data-code-focus="4">Set low and high at the beginning</span>

</script></section><section data-markdown><script type="text/template">

### Binary search for tuple

```c++
template <std::size_t low, std::size_t high, class Result, class Range, class Value,
          class Less, class Equal, class F>
constexpr std::enable_if_t<(high - low >= 2), std::optional<Result>> binary_search_impl(
    const Range& range, const Value& value, Less&& less, Equal&& equal, F&& function) {
  if (less(value, hana::at_c<hana::size_c<(low + high) / 2>>(range))) {
    return binary_search_impl<low, (low + high) / 2, Result>(range, value,
      std::forward<Less>(less), std::forward<Equal>(equal), std::forward<F>(function));
  } else {
    return binary_search_impl<(low + high) / 2, high, Result>(range, value,
      std::forward<Less>(less), std::forward<Equal>(equal), std::forward<F>(function));
  }
}
```
<span class="fragment current-only" data-code-focus="5-7">If value less than middle use left subrange</span>
<span class="fragment current-only" data-code-focus="8-10">Otherwise use right subrange</span>

</script></section><section data-markdown><script type="text/template">

For single element just check equality
```c++
template <std::size_t low, std::size_t high, class Result, class Range, class Value,
            class Less, class Equal, class F>
constexpr std::enable_if_t<(high - low == 1), std::optional<Result>> binary_search_impl(
    const Range& range, const Value& value, Less&&, Equal&& equal, F&& function) {
  if (equal(value, hana::at_c<low>(range))) {
    return function(hana::at_c<low>(range));
  } else {
    return {};
  }
}
```

</script></section><section data-markdown><script type="text/template">
For empty return empty optional
```c++
template <std::size_t low, std::size_t high, class Result, class Range, class Value,
          class Less, class Equal, class Function>
constexpr std::enable_if_t<(high == low), std::optional<Result>> binary_search_impl(
    const Range&, const Value&, Less&&, Equal&&, Function&&) {
  return {};
}
```

</script></section><section data-markdown><script type="text/template">

Now alternative operator should return ordered tuple
```c++
template <class ... Lhs, class ... Rhs>
constexpr auto operator |(const Tree<hana::tuple<Lhs ...>>& lhs,
                          const Tree<hana::tuple<Rhs ...>>& rhs) {
  return tree(hana::concat(
      hana::sort.by(hana::ordering(hana::first),
        hana::concat(hana::filter(lhs.value, is_location),
                     hana::filter(rhs.value, is_location))
      ),
      hana::concat(hana::sort.by(hana::ordering(hana::first),
          hana::concat(hana::filter(lhs.value, is_method),
                       hana::filter(rhs.value, is_method))
        ),
        hana::concat(
          hana::filter(lhs.value, is_handler),
          hana::concat(
            hana::filter(rhs.value, is_handler),
            hana::concat(hana::filter(lhs.value, is_parameter),
                         hana::filter(rhs.value, is_parameter))
    )))));
}
```

</script></section><section data-markdown><script type="text/template">

### Let's implement route

```c++
template <class T, class Path, class MethodName, class ... Args>
constexpr void route(const Tree<T>& tree, const Path& path,
    const MethodName& method, Args&& ... args) {
  using ContextType = Context<typename Path::const_iterator, std::decay_t<MethodName>>;
  return route_for_tuple(
    ContextType {std::cbegin(path), std::cend(path), method},
    tree.value,
    hana::tuple<>(),
    std::forward<Args>(args) ...
  );
}
```

</script></section><section data-markdown><script type="text/template">

### Before implement deeper is there anything we forget?

</script></section><section data-markdown><script type="text/template">

### Return value!

</script></section><section data-markdown><script type="text/template">

```c++
template <class Result, class T, class Path, class MethodName, class ... Args>
constexpr CallResult<Result> route(const Tree<T>& tree, const Path& path,
    const MethodName& method, Args&& ... args) {
  using ContextType = Context<typename Path::const_iterator, std::decay_t<MethodName>>;
  return route_for_tuple<Result>(
    ContextType {std::cbegin(path), std::cend(path), method},
    tree.value,
    hana::tuple<>(),
    std::forward<Args>(args) ...
  );
}
```
</script></section><section data-markdown><script type="text/template">

### Return type

```c++
enum class ErrorCode {
  ok,
  methodNotFound,
  locationNotFound,
};

template <class T>
using CallResult = std::variant<
  std::conditional_t<std::is_same_v<T, void>, std::monostate, T>,
  ErrorCode
>;
```

<span class="fragment current-only" data-code-focus="1-5">To have no deal with exceptions for errors</span>
<span class="fragment current-only" data-code-focus="7-11">Emulate std::expected</span>
<span class="fragment current-only" data-code-focus="9">Replace void with std::monostate to be able return "void" inside variant</span>
</script></section><section data-markdown><script type="text/template">

```c++
template <class R, class C, class P, class ... Key, class ... Node, class ... Args>
constexpr CallResult<R> route_for_tuple(const C& context,
    const hana::tuple<hana::pair<Key, Node> ...>& node, P&& parameters,
    Args&& ... args) {
  if (!at_path_end(context)) {
    if (auto result = route_for_location<R>(context, hana::filter(node, is_location),
                                               std::forward<Args>(args) ...)) {
        return std::move(result).value();
    }
    return route_for_parameter<R>(context, hana::filter(node, is_parameter),
                                     std::forward<Args>(args) ...);
  }
  return route_for_method<R>(context, hana::filter(node, is_method),
                                std::forward<Args>(args) ...);
}
```

<span class="fragment current-only" data-code-focus="5">If current path iterator is not the end of the path</span>
<span class="fragment current-only" data-code-focus="6-7">Try to use path value as location</span>
<span class="fragment current-only" data-code-focus="8">Return if it is</span>
<span class="fragment current-only" data-code-focus="10-11">Otherwise use path value as parameter</span>
<span class="fragment current-only" data-code-focus="13-14">If path is ended use method</span>

</script></section><section data-markdown><script type="text/template">

```c++
template <class R, class Context, class Parameters, class ... Args>
constexpr std::optional<CallResult<R>> route_for_location(const Context&,
    const hana::tuple<>& /* node */, Parameters&&, Args&& ...) {
  return {};
}

template <class R, class C, class P, class ... Key, class ... Node, class ... Args>
constexpr std::optional<CallResult<R>> route_for_location(const C& context,
    const hana::tuple<hana::pair<Location<Key>, Node> ...>& node,
    P&& parameters, Args&& ... args) {
  return binary_search<CallResult<R>>(node, get_path_value(context), Less {}, Equal {},
    return_monostate_on_void([&] (const auto& next) {
      return route_for_tuple<Result>(
        with_next_path_iterator(context),
        hana::second(next),
        std::forward<Parameters>(parameters), std::forward<Args>(args) ...
      );
    })
  );
}
```

<span class="fragment current-only" data-code-focus="3-4">If there is no locations return nullopt</span>
<span class="fragment current-only" data-code-focus="12-19">If there are locations, use binary search to find one</span>
<span class="fragment current-only" data-code-focus="13-17">And do recursive call for next path value</span>
<span class="fragment current-only" data-code-focus="14">Using context with next path iterator</span>

</script></section><section data-markdown><script type="text/template">

```c++
template <class R, class C, class Parameters, class T, class Node, class ... Args>
constexpr CallResult<R> route_for_parameter(const C& context,
    const hana::tuple<hana::pair<Parameter<T>, Node>>& node,
    Parameters&& parameters, Args&& ... args) {
  return route_for_tuple<R>(
    with_next_path_iterator(context),
    hana::second(hana::front(node)),
    hana::append(std::forward<Parameters>(parameters),
                 T {get_path_value(context)}),
    std::forward<Args>(args) ...
  );
}
```

<span class="fragment current-only" data-code-focus="7">Use single existing parameter node, checked by static_assert</span>
<span class="fragment current-only" data-code-focus="8-9">Construct parameter value and append to tuple of parameters</span>
<span class="fragment current-only" data-code-focus="5-11">And do recursive call for next path value</span>

</script></section><section data-markdown><script type="text/template">

```c++
template <class R, class Context, class Parameters, class ... Args>
constexpr CallResult<R> route_for_method(const Context&,
    const hana::tuple<>&, Parameters&&, Args&& ...) noexcept {
  return ErrorCode::methodNotFound;
}

template <class R, class C, class P, class ... Name, class ... Node, class ... Args>
constexpr CallResult<R> route_for_method(const C& context,
    const hana::tuple<hana::pair<Method<Name>, Node> ...>& node,
        P&& params, Args&& ... args) {
  auto result = binary_search<CallResult<R>>(node, context.method, Less {}, Equal {},
    return_monostate_on_void([&] (const auto& next) {
        return hana::unpack(std::forward<P>(params), [&] (auto&& ... p) {
            return hana::second(next).impl(std::move(p) ...,
                                           std::forward<Args>(args) ...);
        });
    })
  );
  return result ? std::move(result).value() : ErrorCode::methodNotFound;
}
```

<span class="fragment current-only" data-code-focus="11-18">Find node by method</span>
<span class="fragment current-only" data-code-focus="13-15">And call endpoint handler with given parameters</span>
<span class="fragment current-only" data-code-focus="19">Return handler result or error</span>

</script></section><section data-markdown><script type="text/template">

### Can we do any better?

</script></section><section data-markdown><script type="text/template">

### Let's reduce search complexity from O(log(N)) to O(1)

</script></section><section data-markdown><script type="text/template">

### By using unordered map!

</script></section><section data-markdown><script type="text/template">

### But what is the type of value?

</script></section><section data-markdown><script type="text/template">

### std::variant!

</script></section><section data-markdown><script type="text/template">

```c++
template <class T>
struct Value {};

template <class ... Key, class ... Node>
struct Value<hana::tuple<hana::pair<Key, Node> ...>> {
    using type = std::variant<std::reference_wrapper<const hana::pair<Key, Node>> ...>;
};

template <>
struct Value<hana::tuple<>> {
    using type = std::monostate;
};

template <class T>
using ValueType = typename Value<std::decay_t<T>>::type;
```

<span class="fragment current-only" data-code-focus="1-2">By default we dont't need any type</span>
<span class="fragment current-only" data-code-focus="4-7">Define only for tuple</span>
<span class="fragment current-only" data-code-focus="9-12">Special case when there is no elements</span>

</script></section><section data-markdown><script type="text/template">

Map type is customizable by special traits class template

```c++
template <class ... Ts>
struct UnorderedMapTraits {
  using Type = std::unordered_map<
    KeyType<hana::tuple<Ts ...>>,
    ValueType<hana::tuple<Ts ...>>
  >;
};

template <class ... Ts>
struct UnorderedMapTraits<hana::tuple<Ts ...>> {
  using Type = typename UnorderedMapTraits<Ts ...>::Type;
};
```

</script></section><section data-markdown><script type="text/template">

```c++
template <template <class ...> class MapTraits, class ... Ts>
struct MapRouter {
  hana::tuple<Ts ...> nodes;
  typename LocationsMapTraits<MapTraits, Ts ...>::Type locations;
  typename MethodsMapTraits<MapTraits, Ts ...>::Type methods;

  MapRouter() = default;
  MapRouter(hana::tuple<Ts ...> nodes) : nodes(std::move(nodes)) {
      fill_locations(this->nodes, locations);
      fill_methods(this->nodes, methods);
  }
  MapRouter(const MapRouter& other)  { ... }
  MapRouter(MapRouter&& other) { ... }
};
```

<span class="fragment current-only" data-code-focus="3">Map router contains original nodes</span>
<span class="fragment current-only" data-code-focus="4">locations map</span>
<span class="fragment current-only" data-code-focus="5">and methods map</span>
<span class="fragment current-only" data-code-focus="12-13">Because values in map are references we need special copy and move constructors</span>

</script></section><section data-markdown><script type="text/template">

And if we want to use it for our api we just call special function

```c++
const auto api = use_unordered_map_router(
  "users"_l / user_id / (
    "contacts"_l / contact_id / "GET"_m(get_contact)
    | "lists"_l / "PUT"_m(create_list)
    | "tags"_l / tag_id / "DELETE"_m(delete_tag)
  )
);
```

</script></section><section data-markdown><script type="text/template">

Or for custom map

```c++
template <class ... Ts>
struct MyMap {
  using Type = std::map<
    KeyType<hana::tuple<Ts ...>>,
    ValueType<hana::tuple<Ts ...>>
  >;
};

template <class ... Ts>
struct MyMap<hana::tuple<Ts ...>> {
  using Type = typename MyMap<Ts ...>::Type;
};

const auto api = use_map_router<MyMap>(/* ... */);
```

</script></section><section data-markdown><script type="text/template">

### But how is this all efficient?

</script></section><section data-markdown><script type="text/template">

### Benchmark

```c++
const auto api =
    "users"_l / (
        parameter<UserId> / (
            "contacts"_l / (
                "GET"_m(get_all_contacts)
                | "PUT"_m(create_contact)
                | parameter<ContactId> / (
                    "GET"_m(get_contact)
                    | "DELETE"_m(delete_contact)
                    | "POST"_m(update_contact)
                )
            )
            | "tags"_l / (
                "GET"_m(get_all_tags)
                | "PUT"_m(create_tag)
                | parameter<TagId> / (
                    "GET"_m(get_tag)
                    | "DELETE"_m(delete_tag)
                    | "POST"_m(update_tag)
                )
            )
        )
    )
;
```

</script></section><section data-markdown><script type="text/template">

<canvas data-chart="bar">
<!--
{
  "data": {
    "labels": [
      "naive",
      "virtual methods",
      "virtual methods & variant",
      "binary search",
      "unordered map"
    ],
    "datasets": [{
      "data": [436, 479, 511, 450, 13202],
      "label": "cpu time, ns",
      "backgroundColor": "rgba(20, 220, 220, 1)"
    }]
  }
}
-->
</canvas>

</script></section><section data-markdown><script type="text/template">

### Without unordered_map

  <canvas data-chart="bar">
  <!--
  {
    "data": {
      "labels": [
        "naive",
        "virtual methods",
        "virtual methods & variant",
        "binary search"
      ],
      "datasets": [{
        "data": [436, 479, 511, 450],
        "label": "cpu time, ns",
        "backgroundColor": "rgba(20, 220, 220, 1)"
      }]
    },
    "options": {
        "scales": {
            "yAxes": [{
                "ticks": {
                    "beginAtZero": true
                }
            }]
        }
    }
  }
  -->
  </canvas>

</script></section><section data-markdown><script type="text/template">

### Single level with integers with known input

  <canvas data-chart="line">
  <!--
  {
    "data": {
      "labels": [1, 2, 4, 8, 16, 32],
      "datasets": [{
        "data": [20, 29, null],
        "label": "naive, ns",
        "fill": false,
        "lineTension": 0
      }, {
        "data": [null, 29, 32, 34],
        "label": "naive with switch, ns",
        "fill": false,
        "lineTension": 0
      }, {
        "data": [20, 29, 33, 37, 39, 42],
        "label": "binary search, ns",
        "fill": false,
        "lineTension": 0
      }, {
        "data": [20, 29, 41, 46, 46, 48],
        "label": "unordered map, ns",
        "fill": false,
        "lineTension": 0
      }]
    },
    "options": {
        "scales": {
            "yAxes": [{
                "ticks": {
                    "beginAtZero": true
                }
            }]
        }
    }
  }
  -->
  </canvas>

</script></section><section data-markdown><script type="text/template">

### 4 levels with known input
3 with 4 locations each, 4 methods

  <canvas data-chart="bar">
  <!--
  {
    "data": {
      "labels": ["binary search", "unordered map"],
      "datasets": [{
        "data": [244, 188],
        "label": "cpu time, ns",
        "backgroundColor": "rgba(20, 220, 220, 1)"
      }]
    },
    "options": {
        "scales": {
            "yAxes": [{
                "ticks": {
                    "beginAtZero": true
                }
            }]
        }
    }
  }
  -->
  </canvas>

          </script>
        </section>
      </div>
    </div>

    <script src="js/jquery-3.3.1.min.js"></script>
    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>
    <script>
      Reveal.initialize({
        slideNumber: 'c',
        controls: true,
        progress: true,
        history: true,
        center: true,
        transitions: 'none',
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js' },
          { src: 'reveal.js/plugin/markdown/markdown.js' },
          { src: 'highlight/highlight.pack.js' },
          { src: 'plugins/reveal-code-focus/reveal-code-focus.js', callback: function() { RevealCodeFocus(); } },
          { src: 'plugins/reveal.js-plugins/chart/Chart.min.js' },
          { src: 'plugins/reveal.js-plugins/chart/csv2chart.js' },
          { src: 'plugins/reveal.js-plugins/chart/sampler.js' },
        ],
        chart: {
          defaults: {
            global: {
              title: { fontColor: "#FFF", defaultFontSize: 16 },
              legend: {
                labels: { fontColor: "#FFF", defaultFontSize: 16 },
              },
            },
            scale: {
              scaleLabel: { fontColor: "#FFF", defaultFontSize: 16 },
              gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
              ticks: { fontColor: "#FFF", defaultFontSize: 16 },
            }
          },
          line: { borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ], "borderDash": [ [5,10], [0,0] ]},
          bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ], defaultFontSize: 16 },
          pie: { backgroundColor: [ ["rgba(0,0,0,.8)" , "rgba(220,20,20,.8)", "rgba(20,220,20,.8)", "rgba(220,220,20,.8)", "rgba(20,20,220,.8)"] ]},
          radar: { borderColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)" ]},
        },
      });

      // Add the line-numbers class to all code blocks, so that code examples
      // have line numbers.
      // Reveal.addEventListener('ready', function(event) {
      //   $("pre>code").each(function(index, block) {
      //     block.classList.add("line-numbers");
      //   });
      // });

      // When the current slide contains an element with id '#godbolt', we reload
      // the iframe. This is to workaround a bug where the iframe would otherwise
      // not be painted properly.
      Reveal.addEventListener('slidechanged', function(event) {
        var godbolt = event.currentSlide.querySelector("#godbolt");
        if (godbolt != undefined) {
          console.log("Reloading godbolt iframe");
          godbolt.contentWindow.location.reload(true);
        }
      });
    </script>
  </body>
</html>
